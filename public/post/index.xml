<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jonas Blog</title>
    <link>http://jonasriedel.de/post/</link>
    <description>Recent content in Posts on Jonas Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language>
    <lastBuildDate>Mon, 28 Mar 2016 22:22:11 +0200</lastBuildDate>
    <atom:link href="http://jonasriedel.de/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TLS HTTP SERVER IN GO MIT EIGENEM ZERTIFIKAT</title>
      <link>http://jonasriedel.de/post/gotlsstart/</link>
      <pubDate>Mon, 28 Mar 2016 22:22:11 +0200</pubDate>
      
      <guid>http://jonasriedel.de/post/gotlsstart/</guid>
      <description>&lt;p&gt;HTTPS als Server in go zu nutzen ist eigentlich ganz einfach, trotzdem vergesse ich auch gerne welche Schritte dazu notwendig sind. Hier jetzt ein Blog Eintrag als Gedächnisstütze.&lt;/p&gt;

&lt;p&gt;Um HTTPS nutzen zu können muss man ein Zertifikat erstellen. Unter Linux ist das schnell erledigt.
Zuerst den private key erzeugen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl genrsa -out server.key 2048
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dann damit das eigentliche Zertifikat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl req -new -x509 -key server.key -out server.pem -days 3650
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, jetzt nur noch einen kleines Program mit dem Webserver:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
)


func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &amp;quot;Hello world&amp;quot;!)
}

func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, handler)
	http.ListenAndServeTLS(&amp;quot;:8080&amp;quot;, &amp;quot;server.pem&amp;quot;, &amp;quot;server.key&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unter &lt;a href=&#34;https://127.0.0.1:8080/&#34;&gt;https://127.0.0.1:8080/&lt;/a&gt; gibts jetzt ein TLS verschlüsseltes &amp;ldquo;Hello World!&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SOLENOIDVENTIL FÜR DELONGHI LATTISSIMA 680 TAUSCHEN</title>
      <link>http://jonasriedel.de/post/latissima/</link>
      <pubDate>Sun, 20 Mar 2016 19:34:23 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/latissima/</guid>
      <description>&lt;p&gt;Heute habe ich mal mit &lt;em&gt;richtiger&lt;/em&gt; Hardware gearbeitet. Meine Kaffeemaschine von DeLonghi, die Lattissima EN680 hat keinen Milchschaum mehr gemacht.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/latissima_aussen.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Der Dampf für diese Funktion geht durch ein sogenanntes Solenoidventil. Das war wohl defekt. Also bei &lt;a href=&#34;http://www.ebay.de/itm/370615009376&#34;&gt;ebay&lt;/a&gt; kurz ein neues geordert (Ich hatte die Version mit Metall-Anschlüssen).
So, jetzt aber erstmal die Maschine öffnen,das ist eigentlich relativ einfach, man muss nur von hinten die beiden Schrauben auf der rechten Seite  entfernen. Schon liegen die Innereien vor einem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/latissima.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Das entsprechende Ventil sitzt auf rechts unten, hinter der Stelle wo der Milchbehälter hin gehört.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/ventil_nah.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Es führen 3 Wasser-Anschlüsse zum Ventil, einer von oben und jeweils einer von der Seite dann sind noch ein paar Kabel dran. Also zuerst die Kabel entfernen (natürlich vorher Netzstecker ziehen !!) und dann das Ventil entnehmen, es steckt in einer Gummihalterung, kann aber mit etwas hin und her drehen entnommen werden.&lt;/p&gt;

&lt;p&gt;Der Schlauch an der rechten Seite ist mit eine Schelle festgemacht, die sich nicht öffnen lässt, also zuerst die anderen Schläuche entfernen und dann einfach das rechte Gewindestück mit dem Schlauch dran raus drehen.&lt;/p&gt;

&lt;p&gt;Wenn man jetzt das neue Ventil einsetzt muss man darauf achten, das die Anschlüsse von innen unterschiedlich aussehen. Ich musste den unteren Metall-Teil um 180° drehen damit es mit dem alten Ventil übereinstimmt.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/ventil1.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://jonasriedel.de/post/ventil2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dann wieder alle Schläuche und Kabel dran, das Ventil wieder einsetzen und einen leckeren Capuccino trinken.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MIT SYSTEMD DOCKER CONTAINER STARTEN</title>
      <link>http://jonasriedel.de/post/systemd/</link>
      <pubDate>Sun, 13 Mar 2016 18:08:33 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/systemd/</guid>
      <description>&lt;p&gt;Auf meinem &lt;a href=&#34;http://jonasriedel.de/post/first&#34;&gt;Raspberry Pi Docker Cluster&lt;/a&gt; habe ich den Service-Discocvery Dienst Consul als Container installiert. Damit das Teil jetzt auch nach einem reboot startet, wird jetzt ein systemd Service eingerichtet der Consul automatisch startet.&lt;/p&gt;

&lt;p&gt;Dazu legen wir als root die Datei &lt;code&gt;/etc/systemd/system/consul.service&lt;/code&gt; an mit folgendem Inhalt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Consul
After=docker.service
Requires=docker.service

[Service]
TimeoutStartSec=0
ExecStart=/usr/bin/docker start consul
ExecStop=/usr/bin/docker stop consul

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hier beschreiben wir den Dienst &amp;ldquo;Consul&amp;rdquo; und sagen das er nach dem Docker-Service gestartet werden soll. Das wars schon. Natürlich muss die Datei auf alle Cluster Pi&amp;rsquo;s kopiert werden.
Dann noch den Service aktivieren&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable  /etc/systemd/system/consul.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;und erstmal den Dienst von Hand starten&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start consul.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, jetzt sollte der Consul Container laufen und auch beim nächsten Systemstart automatisch geladen werden.
War ja einfach&amp;hellip;..&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Datadog für Raspberry Pi</title>
      <link>http://jonasriedel.de/post/datadog/</link>
      <pubDate>Fri, 11 Mar 2016 20:29:05 +0000</pubDate>
      
      <guid>http://jonasriedel.de/post/datadog/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;Datadog ist eine Online-Monitoring Webseite. Dort kann man diverse Metriken visualisieren lassen. Im konstenlosen Basispaket sind bis zu 5 Hosts enthalten. Genau richtig für &lt;a href=&#34;http://jonasriedel.de/post/first/&#34;&gt;mein Raspberry Pi Cluster&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Da Datadog kein Binary für den Raspberry bereitstellt, nimmt man am besten die Python Variante. Dazu muss folgendes gemacht werden:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install sysstat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dann muss man in seinem Datadog Account bei &amp;ldquo;Installation Instructions&amp;rdquo; die Auswahl &amp;ldquo;From Source&amp;rdquo; treffen und den gezeigten Befehl in der Console ausführen.
&lt;img src=&#34;http://jonasriedel.de/post/datadog.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Also dann den entsprechenden Befehl ausführen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DD_API_KEY=&amp;lt;API_KEY&amp;gt; sh -c &amp;quot;$(curl -L https://raw.githubusercontent.com/DataDog/dd-agent/master/packaging/datadog-agent/source/setup_agent.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wenn der Agent korrekt gestartet wurde sollte das irgendwann so aussehen:
&lt;img src=&#34;http://jonasriedel.de/post/datadogagent.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Wenn man jetzt CRTL-C drückt, bricht man den Agent ab, ist ja irgendwie suboptimal&amp;hellip;.
Also hier ein kleines inti.d Script was den Agent als Service starten kann:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
# /etc/init.d/datadog

### BEGIN INIT INFO
# Provides:          datadog
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Datadog Agent start script
# Description:       This service is used to provide data to datadog
### END INIT INFO


case &amp;quot;$1&amp;quot; in
    start)
        echo &amp;quot;Starting datadog agent&amp;quot;
        nohup /root/.datadog-agent/bin/agent 2&amp;gt;&amp;amp;1 &amp;gt;/var/log/datadog.log &amp;amp;
        ;;
    stop)
        echo &amp;quot;Stopping datadog agent&amp;quot;
        killall agent
        ;;
    *)
        echo &amp;quot;Usage: /etc/init.d/datadog start|stop&amp;quot;
        exit 1
        ;;
esac

exit 0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eventuell müsst ihr den Pfad &lt;code&gt;/root/.datadog-agent/bin/agent&lt;/code&gt; anpassen, jenachdem wo ihr das Paket runtergeladen habt.
Das Script in die Datei &lt;code&gt;/etc/init.d/datadog&lt;/code&gt; kopieren, dann wird der Agent beim booten gestartet. Von Hand geht das dann so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;service datadog start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt kann man in Datadog seine Metriken visualisieren, mein Dashboard für meine 3 Pi&amp;rsquo;s sieht z.B. so aus:
&lt;img src=&#34;http://jonasriedel.de/post/datadogdashboard.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi 3 Docker Swarm Cluster</title>
      <link>http://jonasriedel.de/post/first/</link>
      <pubDate>Sat, 05 Mar 2016 15:40:59 +0000</pubDate>
      
      <guid>http://jonasriedel.de/post/first/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;Der Raspberry 3 hat ja noch mehr Power als die beiden Vorgänger und eignet sich damit noch besser als Docker Plattform.
Mit mehreren Raspberrys kann man sich für schmales Geld einen schönen Cluster aufbauen.&lt;/p&gt;

&lt;p&gt;Ich habe dafür folgendes genommen:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pollin.de/shop/dt/OTQxNzkyOTk-/Bausaetze_Module/Entwicklerboards/Raspberry_PI/Raspberry_Pi_3_Modell_B.html&#34;&gt;3x Raspberry Pi 3 (Pollin)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.de/gp/product/B013OW6YDM/ref=as_li_tl?ie=UTF8&amp;amp;camp=1638&amp;amp;creative=19454&amp;amp;creativeASIN=B013OW6YDM&amp;amp;linkCode=as2&amp;amp;tag=jonasriedelde-21&#34;&gt;1x 5-fach USB Netzteil (Amazon)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.de/gp/product/B00N0OHEMA/ref=as_li_tl?ie=UTF8&amp;amp;camp=1638&amp;amp;creative=19454&amp;amp;creativeASIN=B00N0OHEMA&amp;amp;linkCode=as2&amp;amp;tag=jonasriedelde-21&#34;&gt;1x 5-fach Switch (Amazon)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.de/gp/product/B00IHIZF8Y/ref=as_li_tl?ie=UTF8&amp;amp;camp=1638&amp;amp;creative=19454&amp;amp;creativeASIN=B00IHIZF8Y&amp;amp;linkCode=as2&amp;amp;tag=jonasriedelde-21&#34;&gt;3x Patchkabel 15cm (Amazon)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dann die &amp;ldquo;normale&amp;rdquo; Distribution von der Raspberry Seite herunter laden. Hab die &lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;&amp;ldquo;Lite&amp;rdquo; Version von Raspbian&lt;/a&gt; genommen, da ich keine grafische Oberfläche brauche und man so mehr Platz hat.&lt;/p&gt;

&lt;p&gt;Die auf die SD-Karten installieren und damit booten.&lt;/p&gt;

&lt;p&gt;Dann per SSH auf den Dingern einloggen.&lt;/p&gt;

&lt;p&gt;So, jetzt die Docker Version für den Raspberry von &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;Hypriot&lt;/a&gt; runterladen, als root installieren, Service für autostart einrichten und dann rebooten:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://downloads.hypriot.com/docker-hypriot_1.10.2-1_armhf.deb
dpkg -i docker-hypriot_1.10.2-1_armhf.deb
systemctl enable docker.service
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nach dem reboot dann checken ob docker korrekt installiert ist:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo docker version

Client:
 Version:      1.10.2
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   c3959b1
 Built:        Wed Feb 24 09:51:38 2016
 OS/Arch:      linux/arm

Server:
 Version:      1.10.2
 API version:  1.22
 Go version:   go1.4.3
 Git commit:   c3959b1
 Built:        Wed Feb 24 09:51:38 2016
 OS/Arch:      linux/arm

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dann bocker-machine runterladen (gibts als fertiges Binary bei hypriot)
Umbenennen und z.B. nach /usr/bin kopieren (als root)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; wget https://downloads.hypriot.com/docker-machine_darwin-amd64_0.4.1
 mv docker-machine_darwin-amd64_0.4.1 docker-machine
 cp docker-machine /usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Damit docker-machine seien Arbeit verrichten kann, muss es einen autologin für root geben. Dazu muss einiges gemacht werden.&lt;/p&gt;

&lt;p&gt;Als erstes in der Datei &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; die folgende Zeile anpassen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PermitRootLogin yes 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt sollte ein SSH-Login für root möglich sein. Noch einen passenden Key erstellen und auf die Systeme kopieren (auch auf das aktuelle):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#als root:
#autologin schlüssel anlegen
ssh-keygen
ssh-copy-id root@raspberrypi1
ssh-copy-id root@raspberrypi2
ssh-copy-id root@raspberrypi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt kann man mit docker-machine von einem Raspberry die alle Raspberrys mit einem Swarm Client versorgen. Das token müsst ihr durch einen entsprechend langen hex-String ersetzen. Es sorgt dafür, das sich die Cluster Member über einen Docker Webservice im Internet finden. Die IP Adressen müsst ihr natürlich entsprechend für euer Netz anpassen. Pi1-Pi3 sind hierbei die Hostnamen der Systeme die Docker gleich neu setzt. Als &amp;ldquo;driver&amp;rdquo; für docker-machine wird hier &amp;ldquo;generic&amp;rdquo; verwendet, d.h. docker-machine versucht die Provisionierung per SSH vorzunehmen. Dazu eben der autologin für root&amp;hellip;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-machine -D create -d generic --swarm  --swarm-discovery token://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --generic-ip-address 192.168.178.119 pi1
docker-machine -D create -d generic --swarm  --swarm-discovery token://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --generic-ip-address 192.168.178.118 pi2
docker-machine -D create -d generic --swarm  --swarm-discovery token://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx --generic-ip-address 192.168.178.120 pi3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, wenn jetzt alles funktioniert hat, sollte ein Docker Swarm Agent auf allen Pi&amp;rsquo;s laufen.&lt;/p&gt;

&lt;p&gt;Um das zu checken kann man mal &lt;code&gt;docker info&lt;/code&gt; als root auf den Kisten aufrufen, sollte irgendwie so ausehen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@pi2:~# docker info
Containers: 9
 Running: 3
 Paused: 0
 Stopped: 6
Images: 3
Server Version: 1.10.2
Storage Driver: overlay
 Backing Filesystem: extfs
Execution Driver: native-0.2
Logging Driver: json-file
Plugins:
 Volume: local
 Network: bridge null host
Kernel Version: 4.1.18-v7+
Operating System: Raspbian GNU/Linux 8 (jessie)
OSType: linux
Architecture: armv7l
CPUs: 4
Total Memory: 925.8 MiB
Name: pi2
ID: T3GD:TEP7:6FZP:YFT3:U7PE:I653:YAKT:MVZU:F5U2:QTX5:ED72:CUSU
WARNING: No memory limit support
WARNING: No swap limit support
WARNING: No oom kill disable support
WARNING: No cpu cfs quota support
WARNING: No cpu cfs period support
Labels:
 provider=generic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Soweit so unspektakulär. Um jetzt den Cluster zu &lt;em&gt;sehen&lt;/em&gt; muss man quasi die passende Umbebungsvariablen setzen damit docker mit dem Cluster spricht. Das kann mit &lt;code&gt;eval $(docker-machine env --swarm pi3)&lt;/code&gt; erledigt werden (egal welche Host man da angibt). Wenn das erfolgt ist sollte die &lt;code&gt;docker info&lt;/code&gt; Ausgabe wie folgt aussehen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@pi1:~# eval $(docker-machine env --swarm pi3)
root@pi1:~# docker info
Containers: 33
 Running: 8
 Paused: 0
 Stopped: 25
Images: 9
Server Version: swarm/1.1.2
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 pi1: 192.168.178.119:2376
  └ Status: Healthy
  └ Containers: 18
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 972.1 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.18-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-07T21:05:37Z
 pi2: 192.168.178.118:2376
  └ Status: Healthy
  └ Containers: 9
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 972.1 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.18-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-07T21:05:18Z
 pi3: 192.168.178.120:2376
  └ Status: Healthy
  └ Containers: 6
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 972.1 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.18-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-07T21:05:32Z
Plugins:
 Volume:
 Network:
Kernel Version: 4.1.18-v7+
Operating System: linux
Architecture: arm
CPUs: 12
Total Memory: 2.848 GiB
Name: d3de84a6c6b9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Da steht schon mal was von &lt;code&gt;CPUs: 12&lt;/code&gt;, das ist ja schon mal ganz cool, der Cluster läuft also !&lt;/p&gt;

&lt;p&gt;Was man jetzt damit anstellen kann folgt in einem anderen Post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CROSSCOMPILING MIT GO</title>
      <link>http://jonasriedel.de/post/crosscompiling/</link>
      <pubDate>Tue, 15 Sep 2015 21:37:23 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/crosscompiling/</guid>
      <description>

&lt;p&gt;Mit go 1.5 ist das cross compilieren nochmal deutlich einfacher geworden, zumindest wenn kein cgo im Spiel ist. Aber auch sonst ist es nicht kompliziert.&lt;/p&gt;

&lt;h2 id=&#34;bootstrapping:a2bea2f220fcf8042f6ccefcd0dee60f&#34;&gt;Bootstrapping&lt;/h2&gt;

&lt;p&gt;Wenn man doch mal die go Toolchain bootstrappen muss geht das unter Windows wie folgt:&lt;/p&gt;

&lt;h2 id=&#34;schritt-für-schritt-anleitung:a2bea2f220fcf8042f6ccefcd0dee60f&#34;&gt;Schritt-für-Schritt-Anleitung&lt;/h2&gt;

&lt;p&gt;Gcc für Windows runterladen z.B. MinGW: hier &lt;a href=&#34;https://sourceforge.net/projects/mingw/files/latest/download&#34;&gt;https://sourceforge.net/projects/mingw/files/latest/download&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Gcc über GUI installieren&lt;/p&gt;

&lt;p&gt;Path für c:\MinGW\bin setzen&lt;/p&gt;

&lt;p&gt;Nach c:\Go\src wechseln&lt;/p&gt;

&lt;p&gt;Folgendes ausführen (Erzeugt Bootstrap für Linux 32 bit):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	env CGO_ENABLED=1 GOROOT_BOOTSTRAP=c:\\Go GOOS=linux GOARCH=386 make.bat --no-clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Folgendes ausfürhren (Erzeugt Bootstrap für Linux 64 bit):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	env CGO_ENABLED=1 GOROOT_BOOTSTRAP=c:\\Go GOOS=linux GOARCH=amd64 make.bat --no-clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt kann man wie folgt cross compilen:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ziel: Linux 32bit&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GOOS=linux GOARCH=386 go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ergebnis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file goCsv2Xlsx
goCsv2Xlsx32: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ziel: Linux64bit&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GOOS=linux GOARCH=amd64 go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ergebnis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ file goCsv2Xlsx
goCsv2Xlsx: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generell werden folgende Zielarchitekturen unterstützt:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$GOOS&lt;/th&gt;
&lt;th&gt;$GOARCH&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;arm64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;ppc64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;ppc64le&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;solaris&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266 AM PC TESTEN</title>
      <link>http://jonasriedel.de/post/espampc/</link>
      <pubDate>Sun, 16 Aug 2015 20:18:19 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/espampc/</guid>
      <description>&lt;p&gt;Habe eine ESP8266 (WLAN Chip mit serieller Schnittstelle) und wollte den schon mal am PC betreiben um zu sehen ob alles funktioniert. Der ESP benötigt 3.3V der USB2Serial Adapter (ein CP2102) kann aber auf seinem 3.3V Pin nicht genügend Strom liefern, deswegen habe ich ein LD33 benutzt um die 5V vom USB auf die benötigten 3.3V zu wandeln.&lt;/p&gt;

&lt;p&gt;So siehts momentan aus&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/ESP8266Variante1a.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ein paar AT Befehle später hatte der ESP eine IP Adresse aus meinem WLAN:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;at 
OK

//resetten
AT+RST 
OK
bBJG&amp;amp;SbrVHH7dNFJ$dVHJ
[Vendor:www.ai-thinker.com Version:0.9.2.4]

ready

//passenden mode setzen
AT+CWMODE=3 
OK

//wlans auflisten
AT+CWLAP 
+CWLAP:(4,&amp;quot;sid&amp;quot;,-83,&amp;quot;9c:c7:xx:xx:xx:xx&amp;quot;,7)

//in gewünschtes wlan einloggen
AT+CWJAP=&amp;quot;sid&amp;quot;,&amp;quot;passwort&amp;quot; 
OK

//aktuelles (also verbundenes) wlan abfragen
AT+CWJAP? 
+CWJAP:&amp;quot;sid&amp;quot;

//status abfragen (2=verbunden mit wlan)
AT+CIPSTATUS 
STATUS:2
OK

//aktuelle IP abfragen
AT+CIFSR 192.168.4.1
192.168.178.73
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm&amp;hellip;..das war ja einfach&amp;hellip;.als nächstes werde ich mal ein einfaches Programm auf den ESP laden.&lt;/p&gt;

&lt;p&gt;Ach ja, eine Liste der AT Befehle gibt‘s &lt;a href=&#34;http://www.pighixxx.com/test/wp-content/uploads/2014/12/ESP8266Ref.pdf&#34;&gt;hier&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ESP8266-01 MIT DHT22 UND THINGSPEAK ANBINDUNG</title>
      <link>http://jonasriedel.de/post/espdhtthingspeak/</link>
      <pubDate>Sat, 08 Aug 2015 22:13:07 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/espdhtthingspeak/</guid>
      <description>

&lt;p&gt;So, nachdem der ESP8266 generell funktioniert hat und sich per AT Befehl ansprechen ließ, wollte ich das Ding jetzt mal &amp;ldquo;richtig&amp;rdquo; programmieren.
Dazu die Arduino IDE entsprechend &lt;a href=&#34;https://github.com/esp8266/Arduino&#34;&gt;dieser Anleitung&lt;/a&gt; heruntergeladen und installiert.&lt;/p&gt;

&lt;p&gt;Dann wollte ich die Temperatur und Feutchtigkeit mit einem DHT22 messen und an einen Server im Internet schicken um sie grafisch darzustellen. Temperaturmessung mit einem DHT ist für mich quasi das &amp;ldquo;Hello World&amp;rdquo; für neue Boards.&lt;/p&gt;

&lt;p&gt;Die finale Schaltung mit dem DHT22 und dem ESP8266-01 sieht dann wie folgt aus:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/ESP8266_DHT22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Dann habe ich den Code von dieser Seite genommen und etwas angepasst:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Original Code from:
// |www.arduinesp.com
// |
// |Plot DTH11 data on thingspeak.com using an ESP8266
// |April 11 2015
// |Author: Jeroen Beemster
// |Website: www.arduinesp.com
// modified by Jonas Riedel 
// for use with DHT22

#include &amp;lt;DHT.h&amp;gt;
#include &amp;lt;ESP8266WiFi.h&amp;gt;
 
// replace with your channel&#39;s thingspeak API key,
String apiKey = &amp;quot;xxxxxxxxxxxxxxxx&amp;quot;; 
// enter your own Wlan SSID
const char* ssid = &amp;quot;xxxxx&amp;quot;;
//your Wlan Password
const char* password = &amp;quot;xxxxxxxxx&amp;quot;;
 
const char* server = &amp;quot;api.thingspeak.com&amp;quot;;
#define DHTPIN 2 // On ESP8266 01 this is the GPIO2
 
DHT dht(DHTPIN, DHT22, 15); // Use DHT11 for a DHT11 Sensor :-)
WiFiClient client;
 
void setup() {
  Serial.begin(115200);
  delay(10);
  dht.begin();
 
  WiFi.begin(ssid, password);
 
  Serial.println();
  Serial.println();
  Serial.print(&amp;quot;Connecting to &amp;quot;);
  Serial.println(ssid);
 
  WiFi.begin(ssid, password);
 
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&amp;quot;.&amp;quot;); // loop until Wlan connected
  }
  Serial.println(&amp;quot;&amp;quot;);
  Serial.println(&amp;quot;WiFi connected&amp;quot;);
 
}
 
void loop() {
 
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  if (isnan(h) || isnan(t)) {
    Serial.println(&amp;quot;Failed to read from DHT sensor!&amp;quot;);
    delay(500);
    return;
  }
 
  if (client.connect(server,80)) {  
    String postStr = apiKey;
           postStr +=&amp;quot;&amp;amp;field1=&amp;quot;;
           postStr += String(t);
           postStr +=&amp;quot;&amp;amp;field2=&amp;quot;;
           postStr += String(h);
 
     client.print(&amp;quot;POST /update HTTP/1.1\n&amp;quot;);
     client.print(&amp;quot;Host: api.thingspeak.com\n&amp;quot;);
     client.print(&amp;quot;Connection: close\n&amp;quot;);
     client.print(&amp;quot;X-THINGSPEAKAPIKEY: &amp;quot;+apiKey+&amp;quot;\n&amp;quot;);
     client.print(&amp;quot;Content-Type: application/x-www-form-urlencoded\n&amp;quot;);
     client.print(&amp;quot;Content-Length: &amp;quot;);
     client.print(postStr.length());
     client.print(&amp;quot;\n\n&amp;quot;);
     client.print(postStr);
 
     Serial.print(&amp;quot;Temperature: &amp;quot;);
     Serial.print(t);
     Serial.print(&amp;quot; degrees Celcius Humidity: &amp;quot;);
     Serial.print(h);
     Serial.println(&amp;quot;% send to Thingspeak&amp;quot;);
  }
  client.stop();
 
  Serial.println(&amp;quot;Waiting...&amp;quot;);
  // thingspeak needs minimum 15 sec delay between updates but 60s is a good choice here
  delay(60000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entgegen diversen Webseiten, muss in der Arduino IDE als Board zwar &amp;ldquo;Generic ESP8266 Module&amp;rdquo; ausgewählt werden, aber was man als &amp;ldquo;Programmer&amp;rdquo; einstellt ist egal. Das Program muss dann mit dem Menüpunkt &amp;ldquo;Sketch-&amp;gt;Hochladen&amp;rdquo; auf den ESP8266 geladen werden, dann wird automatisch der unter &amp;ldquo;Werkzeug&amp;rdquo; gewählte COM Port (also der USB Anschluss) genutzt. Es muss also nicht &amp;ldquo;esptool&amp;rdquo; als Programmer eingestellt sein !!&lt;/p&gt;

&lt;p&gt;Der eigentliche Trick ist, das der Pin GPIO0 des ESP8266-01 während des programmierens auf GND liegen muss.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/ESP8266Flash.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ich hab dazu einfach die USB Verbindung getrennt, dann den GPIO0 mit GND verbunden und dann wieder die USB Verbindung hergestellt. Dann in der Arduino IDE &amp;ldquo;Sketch-&amp;gt;Hochladen&amp;rdquo; auswählen und der Code wird kompiliert und hochgeladen. Dabei blinkt der ESP.
Dann USB wieder trennen, GND von GPIO0 trennen und USB wieder ran. Dann sollte man über einen seriellen Monitor (ich nehme CoolTerm) die Ausgaben des ESPs sehen:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/cooltermdht22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ich musste dabei immer das DTR Signal abschalten bevor was angezeigt wurde. Dafür in CoolTerm unten einfach auf die DTR LED klicken (wenn die denn leuchtet)&lt;/p&gt;

&lt;p&gt;Wenn alles soweit funktioniert, kann man auf &lt;a href=&#34;https://thingspeak.com/&#34;&gt;Thingspeak&lt;/a&gt; die Daten sehen:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/thingspeakdht22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;update-vom-01-09-2015:10bd9a308c0ecd89aa184f00ed5e0a63&#34;&gt;Update vom 01.09.2015&lt;/h3&gt;

&lt;p&gt;Ich habe die Schaltung mal mit 4 AA (nicht AAA wie in dem Bild) betrieben:&lt;/p&gt;

&lt;p&gt;Wenn das ganze dauerhaft mit dem WLan verbunden ist und alle 5min Daten sendet, hat die Batterie (Eneloop) bei mir ca 46h gehalten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>REALTEK RTL8192CU TREIBER FÜR UBUNTU 13.04 AUF BEAGLEBONE BLACK</title>
      <link>http://jonasriedel.de/post/rtl8192beaglebone/</link>
      <pubDate>Mon, 15 Sep 2014 22:38:41 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/rtl8192beaglebone/</guid>
      <description>&lt;p&gt;Der Beaglebone Black ist ein kleiner Platinencomputer vergleichbar mit dem Raspberry PI, nur mit etwas mehr Power, dafür weniger Multimedia Unterstützung.
Ich wollte da jetzt meinen WLAN Stick von Logilink installieren, aber natürlich funktioniert das nicht out-of-the-box.
Daher hier eine kleine Anleitung wie es geht&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu@beaglebone:~$ uname -a
Linux beaglebone 3.8.13-bone28 #1 SMP Fri Sep 13 03:12:24 UTC 2013 armv7l armv7l armv7l GNU/Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Hier im weiteren auf die passende Version (hier 3.8.13-bone28) achten !!&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu@beaglebone:~$ wget http://www.jonasriedel.de/assets/linux-headers-3.8.13-bone28_1.0raring_armhf.deb

ubuntu@beaglebone:~$ sudo dpkg -i linux-headers-3.8.13-bone28_1.0raring_armhf.deb

ubuntu@beaglebone:~$ wget https://realtek-8188cus-wireless-drivers-3444749-ubuntu-1304.googlecode.com/files/rtl8192cu-tjp-dkms_1.6_all.deb

ubuntu@beaglebone:~$ sudo dpkg -i rtl8192cu-tjp-dkms_1.6_all.deb
# Hier gibt es einen Fehler, das macht aber nichts, da die Sourcefiles dann schon installiert wurden

ubuntu@beaglebone:~$ sudo ln -s /usr/src/linux-headers-3.8.13-bone28/arch/arm /usr/src/linux-headers-3.8.13-bone28/arch/armv7l

ubuntu@beaglebone:~$ sudo vi /usr/src/linux-headers-3.8.13-bone28/arch/armv7l/include/asm/timex.h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hier folgende Zeile ändern:
    #include &lt;mach/timex.h&gt;
zu
    #include &lt;/usr/src/linux-headers-3.8.13-bone28/arch/arm/include/asm/timex.h&gt;
    ubuntu@beaglebone:~$ cd /usr/src/rtl8192cu-tjp-1.6&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu@beaglebone:/usr/src/rtl8192cu-tjp-1.6$ sudo make

ubuntu@beaglebone:/usr/src/rtl8192cu-tjp-1.6$ sudo cp 8192cu.ko /   lib/modules/3.8.13-bone28/kernel/drivers/net/wireless/

ubuntu@beaglebone:/usr/src/rtl8192cu-tjp-1.6$ sudo depmod

ubuntu@beaglebone:/usr/src/rtl8192cu-tjp-1.6$ sudo vi /etc/ modprobe.d/blacklist.conf
Und das hier unten anfügen:
# Blacklist native RealTek 8188CUs drivers 
blacklist rtl8192cu 
blacklist rtl8192c_common 
blacklist rtlwifi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, bei mir wurde jetzt nach einem Reboot das Interface gefunden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu@beaglebone:~$ iwconfig
wlan0     unassociated  Nickname:&amp;quot;&amp;quot;
          Mode:Auto  Frequency=2.412 GHz  Access Point: Not-Associated
          Sensitivity:0/0
          Retry:off   RTS thr:off   Fragment thr:off
          Power Management:off
          Link Quality=0/100  Signal level=0 dBm  Noise level=0 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:0  Invalid misc:0   Missed beacon:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt noch das Interface konfigurieren:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu@beaglebone:~$ sudo vi /etc/network/interfaces

# WiFi Example
auto wlan0
iface wlan0 inet dhcp
wpa-ssid &amp;quot;JRXXXXX&amp;quot;
wpa-psk  &amp;quot;xxxxxxxx&amp;quot;

ubuntu@beaglebone:~$ sudo ifup wlan0


ubuntu@beaglebone:~$ ifconfig -a
...
wlan0     Link encap:Ethernet  HWaddr 00:9e:99:70:28:78
          inet addr:192.168.178.60  Bcast:192.168.178.255  Mask:255.255.255.0
          inet6 addr: fe80::29e:99ff:fe70:2878/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:55 errors:0 dropped:465 overruns:0 frame:0
          TX packets:9 errors:0 dropped:6 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:53628 (53.6 KB)  TX bytes:5518 (5.5 KB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, alles super, läuft.&lt;/p&gt;

&lt;p&gt;PS: Ach ja, der Beaglebone Black hat keinen Hot-Plug USB Anschluß, d.h. Wenn man einen WLAN Stick rein gesteckt hat, muss man nochmal booten damit der erkannt wird.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KARTEN FÜR KANBAN</title>
      <link>http://jonasriedel.de/post/kanbancard/</link>
      <pubDate>Mon, 25 Aug 2014 21:09:08 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/kanbancard/</guid>
      <description>&lt;p&gt;Kanban ist ein Element der agilen Entwicklung. Es ist aber etwas &amp;ldquo;leichtgewichtiger&amp;rdquo; ans Scrum und ich denke das der Umstieg auf Kanban einfacher ist als der Umstieg auf Scrum. Bei Scrum gilt quasi der &amp;ldquo;alles oder nichts&amp;rdquo; Ansatz. Entweder man macht Scrum oder nicht. Kanban kann &amp;ldquo;sanft&amp;rdquo; eingeführt werden, indem man nacheinander einzelne Elemente von Kanban in die eigene Entwicklung übernimmt.&lt;/p&gt;

&lt;p&gt;Als Kanban Neuling liest man am besten erstmal den passenden &lt;a href=&#34;http://de.wikipedia.org/wiki/Kanban_(Softwareentwicklung&#34;&gt;Wikipedia Artikel&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Da Kanban ja übersetzt (mehr oder weniger) &amp;ldquo;Karte&amp;rdquo; bedeutet, merkt man schon das die Kanban Karten ein zentrales Element sind&lt;/p&gt;

&lt;p&gt;Um das erstellen der Kanban Karten zu vereinfachen (und weil ich mal wieder was mit PDF Erstellung machen wollte) habe ich ein kleines Tool geschrieben, mit dem man einfach Kanban Karten erzeugen und als PDF runter laden kann.&lt;/p&gt;

&lt;p&gt;Hier der Link: &lt;a href=&#34;http://kanbancard.de&#34;&gt;http://kanbancard.de&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/kanban.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BULK MUNZEE GENERATOR</title>
      <link>http://jonasriedel.de/post/bulkmunzee/</link>
      <pubDate>Tue, 03 Jun 2014 19:19:16 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/bulkmunzee/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.munzee.com/&#34;&gt;Munzee&lt;/a&gt; ist sowas wie ein Konkurrent für Geocaching. Und eher was für faule Leute, einfach zur angegebenen Position gehen, meistens nicht lang suchen und dann &amp;ldquo;capturen&amp;rdquo; (QR-Code scannen). Gerade das macht für die meisten Anhänger dieser Sportart den Reitz aus. Auch das man im vorübergehen selbst Munzees &amp;ldquo;deployen&amp;rdquo; kann trägt zum Spielspaß bei. Dabei stellt sich allerdings die Frage wie man die Munzees am besten anbringen kann. QR-Code selbst ausdrucken und laminieren ist eine Möglichkeit, oder direkt auf Aufkleber drucken usw. Alles aber sehr zeitaufwändig oder nicht sehr haltbar.&lt;/p&gt;

&lt;p&gt;Eine bessere Möglichkeit sind die Sticker Alben von moo.com, kleine Aufkleber-Heftchen, deren Sticker sehr gut kleben und wasserfest sind.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://jonasriedel.de/post/munzeeblog.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Die Bilder für die Sticker-Alben müssen 283x283 Pixel groß sein. Um hier ein wenig Handarbeit zu sparen, habe ich eine Webseite gemacht, welche den Arbeitsprozess vereinfacht:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://lirumlarum666.appspot.com/bulkmunzee&#34;&gt;http://lirumlarum666.appspot.com/bulkmunzee&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Einfach mal ein Blick rein werfen und dann Munzees deployen !&lt;/p&gt;

&lt;p&gt;Technisch wurde die Webseite als Go Programm realisiert und läuft auf der Google-App-Engine.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GO - GOLANG</title>
      <link>http://jonasriedel.de/post/golang/</link>
      <pubDate>Sat, 24 May 2014 22:09:01 +0100</pubDate>
      
      <guid>http://jonasriedel.de/post/golang/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt; (oder auch Golang) ist eine &amp;ldquo;neue&amp;rdquo; Programmiersprache, die von Google erfunden wurde. Genauer gesagt von Rob Pike und Ken Thomson, die beiden könnte man kennen, da sie auch UTF-8 entwickelt haben.&lt;/p&gt;

&lt;p&gt;Wie immer wenn eine neue Programmiersprache entwickelt wird, wurde auch hier versucht, aus den Problemen der aktuellen Sprachen zu lernen.
So wurde Go zur &amp;ldquo;Programmiersprache des 21. Jahrunderts&amp;rdquo;, mit Garbage Collection, starker Typisierung, Nebenläufigkeit, &amp;ldquo;Duck typing&amp;rdquo; und hoher Internet Affinität.&lt;/p&gt;

&lt;p&gt;Ein einfaches &amp;ldquo;Hello World&amp;rdquo; Programm in Go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
 
import &amp;quot;fmt&amp;quot;
 
func main() {
	fmt.Println(&amp;quot;Hello World&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hier das ganze nochmal, nur das das Go Programm jetzt ein Webserver ist, der eine Webseite mit &amp;ldquo;Hello World&amp;rdquo; zeigt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &amp;quot;Hello World&amp;quot;)
}

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, handler)
    http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Man sieht schon das es sehr einfach ist einen normalen Browser als Frontend für das Go Programm zu benutzen. Bei meinem Programmen lasse ich das Programm auch gerne die Webseiten für das Frontend generieren und gleichzeitig dient es als REST Endpunkt um dynamisch Daten zu liefern.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>